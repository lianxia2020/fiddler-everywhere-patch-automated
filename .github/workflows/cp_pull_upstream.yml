name: Upstream Sync (Full)

permissions:
  contents: write
  issues: write
  actions: write
  packages: write  # æ–°å¢ï¼šéœ€è¦åˆ›å»ºReleasesçš„æƒé™

on:
  schedule:
    - cron: '0 */6 * * *' # every 6 hours
  workflow_dispatch:

jobs:
  sync_latest_from_upstream:
    name: Sync latest commits, releases and assets from upstream repo
    runs-on: ubuntu-latest
    if: ${{ github.event.repository.fork }}  # ä¿®å¤åŸå·¥ä½œæµçš„è¯­æ³•é”™è¯¯ï¼šåŒå¤§æ‹¬å·å³å¯

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # æ–°å¢ï¼šéœ€è¦å®Œæ•´çš„æäº¤å†å²æ¥åŒæ­¥æ ‡ç­¾

      - name: Clean issue notice
        uses: actions-cool/issues-helper@v3
        with:
          actions: 'close-issues'
          labels: 'ğŸš¨ Sync Fail'

      - name: Sync upstream code changes
        id: sync_code
        uses: aormsby/Fork-Sync-With-Upstream-action@v3.4
        with:
          upstream_sync_repo: auto-yui-patch/fiddler-everywhere-patch-automated
          upstream_sync_branch: main
          target_sync_branch: main
          target_repo_token: ${{ secrets.GITHUB_TOKEN }}  # ä¿®å¤åŸå·¥ä½œæµçš„è¯­æ³•é”™è¯¯
          test_mode: false

      - name: Sync upstream release tags
        id: sync_tags
        run: |
          # æ·»åŠ ä¸Šæ¸¸ä»“åº“ä½œä¸ºè¿œç¨‹ä»“åº“
          git remote add upstream https://github.com/auto-yui-patch/fiddler-everywhere-patch-automated.git 
          
          # æ‹‰å–ä¸Šæ¸¸ä»“åº“çš„æ‰€æœ‰æ ‡ç­¾
          git fetch upstream --tags
          
          # æ¨é€æ‰€æœ‰æ ‡ç­¾åˆ°å½“å‰ä»“åº“
          git push origin --tags
        continue-on-error: true  # æ ‡ç­¾åŒæ­¥å¤±è´¥ä¸å½±å“ä¸»æµç¨‹

      - name: Sync upstream releases and assets
        id: sync_releases
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const upstreamRepo = 'auto-yui-patch/fiddler-everywhere-patch-automated';
            const currentRepo = context.repo.owner + '/' + context.repo.repo;
            
            // è·å–ä¸Šæ¸¸ä»“åº“çš„æ‰€æœ‰Releases
            const upstreamReleases = await github.rest.repos.listReleases({
              owner: upstreamRepo.split('/')[0],
              repo: upstreamRepo.split('/')[1],
              per_page: 100
            });
            
            // éå†æ¯ä¸ªRelease
            for (const upstreamRelease of upstreamReleases.data) {
              console.log(`Processing release: ${upstreamRelease.tag_name}`);
              
              try {
                // æ£€æŸ¥å½“å‰ä»“åº“æ˜¯å¦å·²å­˜åœ¨è¯¥Release
                const existingRelease = await github.rest.repos.getReleaseByTag({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag: upstreamRelease.tag_name
                }).catch(() => null);
                
                if (existingRelease) {
                  console.log(`Release ${upstreamRelease.tag_name} already exists, skipping`);
                  continue;
                }
                
                // åˆ›å»ºæ–°çš„Release
                const newRelease = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: upstreamRelease.tag_name,
                  name: upstreamRelease.name,
                  body: upstreamRelease.body,
                  draft: upstreamRelease.draft,
                  prerelease: upstreamRelease.prerelease,
                  target_commitish: upstreamRelease.target_commitish
                });
                
                // ä¸‹è½½å¹¶ä¸Šä¼ æ‰€æœ‰Assets
                for (const asset of upstreamRelease.assets) {
                  console.log(`Processing asset: ${asset.name}`);
                  
                  // ä¸‹è½½Asset
                  const assetResponse = await github.rest.repos.getReleaseAsset({
                    owner: upstreamRepo.split('/')[0],
                    repo: upstreamRepo.split('/')[1],
                    asset_id: asset.id,
                    headers: {
                      accept: 'application/octet-stream'
                    }
                  });
                  
                  // ä¸Šä¼ Assetåˆ°æ–°Release
                  await github.rest.repos.uploadReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: newRelease.data.id,
                    name: asset.name,
                    data: assetResponse.data,
                    headers: {
                      'content-type': asset.content_type,
                      'content-length': asset.size
                    }
                  });
                }
                
                console.log(`Successfully synced release: ${upstreamRelease.tag_name}`);
              } catch (error) {
                console.error(`Failed to sync release ${upstreamRelease.tag_name}:`, error);
                // ç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªReleaseï¼Œä¸ä¸­æ–­æ•´ä¸ªæµç¨‹
              }
            }
        continue-on-error: true  # ReleasesåŒæ­¥å¤±è´¥ä¸å½±å“ä¸»æµç¨‹

      - name: Sync check
        if: failure()
        uses: actions-cool/issues-helper@v3
        with:
          actions: 'create-issue'
          title: 'ğŸš¨ Sync Fail | åŒæ­¥å¤±è´¥'
          labels: 'ğŸš¨ Sync Fail'
          body: |
            Due to a change in the workflow file of the upstream repository, GitHub has automatically suspended the scheduled automatic update. You need to manually sync your fork. 

            ç”±äºä¸Šæ¸¸ä»“åº“çš„å·¥ä½œæµæ–‡ä»¶å‘ç”Ÿäº†æ›´æ”¹ï¼ŒGitHub å·²è‡ªåŠ¨æš‚åœäº†è®¡åˆ’çš„è‡ªåŠ¨æ›´æ–°ã€‚æ‚¨éœ€è¦æ‰‹åŠ¨åŒæ­¥æ‚¨çš„åˆ†å‰ä»“åº“ã€‚

            ![](https://github-production-user-asset-6210df.s3.amazonaws.com/17870709/273954625-df80c890-0822-4ac2-95e6-c990785cbed5.png)
